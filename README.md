# React + Vite
ðŸŽ¯ Create state variables to store the current number of cookies and the cookies PerSecond value (useState) replace cookies with lemons

ðŸŽ¯ Set up a timer to increment the number of cookies by the cookiesPerSecond value (useEffect). Be sure to handle clearing the timer using the useEffect return value. names are correct and match states

ðŸŽ¯ Set up an array of objects containing the items available for purchase in the store, their cost and their increment increase value. Map through these and create buttons for each. - different component, make an array, inside array, objects and upgrades (cost connects to actual amount of lemons, increase value per second connects to LPS) then import into app(use map to display on page) 

ðŸŽ¯ Create a function to handle the purchase of an item. This should check if the user has enough cookies to purchase the item, and if so, subtract the cost of the item from the number of cookies and add the increment value to the cookiesPerSecond value. creat function that checks PSObjects to see if upgrade can be brought, take the cost off the amount of things then increment the things per second

You can load saved values from localStorage as the default value passed to the useState hook

The useEffect dependency array can be used to trigger a function to save the values to localStorage every time they change

explanation of the "Array Array code" 

1.import { useEffect, useState } from "react";: This imports the useEffect and useState hooks from the React library. These hooks are used to manage side effects and state in functional components.
2.const investments = [ /* ... */ ];: This initializes an array called investments containing objects representing different types of investments. Each object includes properties such as name, value, cost, coefficient, timeMultiplier, and quantity.
3.const prettyNumber = (number) => { /* ... */ };: This defines a function called prettyNumber that rounds a number to two decimal places.
4.const FancyButton = (props) => ( /* ... */ );: This defines a functional component called FancyButton which is essentially a button component with customizable styles.
5.export default function App() { /* ... */ }: This is the main functional component named App, which contains the logic for the investment simulation game.
6.const [money, setMoney] = useState(parseInt(localStorage.getItem("money")) || 0);: This initializes the state variable money using the useState hook. It attempts to retrieve the current money value from local storage, or defaults to 0 if no value is found.
7.const [investmentsState, setInvestmentsState] = useState(/* ... */);: This initializes the state variable investmentsState using the useState hook. It represents the state of all investments in the game, including their quantities. The initial state is derived from the investments array and local storage.
8.useEffect(() => { /* ... */ }, [money, investmentsState]);: This useEffect hook is responsible for updating local storage whenever the money or investmentsState variables change.
9.useEffect(() => { /* ... */ }, [setMoney, investmentsState]);: This useEffect hook defines the main game loop. It calculates the profit generated by each investment type based on their quantities and updates the money state accordingly at a set interval.
10.const handleBuy = (index) => { /* ... */ };: This function handles the logic for buying an investment. It subtracts the cost of the investment from the money state and increments the quantity of the corresponding investment in the investmentsState.
11.const handleSell = (index) => { /* ... */ };: This function handles the logic for selling an investment. It adds the value of the investment to the money state and decrements the quantity of the corresponding investment in the investmentsState.
12.return ( /* ... */ );: This is the JSX returned by the App component, containing the UI elements for displaying the current money value, investment buttons, and quantities. Investment buttons are dynamically generated based on the investmentsState array.